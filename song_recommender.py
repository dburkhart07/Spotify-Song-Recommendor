# -*- coding: utf-8 -*-
"""Song Recommender

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1v3uYFRINiPLfdbppl1VFFsIP0tHR5L7y
"""

import pandas as pd
from sklearn.feature_extraction.text import TfidfVectorizer
from sklearn.metrics.pairwise import cosine_similarity

#! pip install kaggle

# Load the dataset
data = pd.read_csv('Best Songs on Spotify from 2000-2023.csv', delimiter=";")

# Remove whitespace from column names
data.columns = data.columns.str.strip()

# Select relevant features for recommendation
features = ['title', 'artist', 'top genre', 'year', 'bpm', 'energy', 'danceability', 'dB', 'liveness', 'valence', 'duration', 'acousticness', 'speechiness', 'popularity']
data = data[features]

# Handling missing values by filling them with mean values
data.fillna(data.mean(), inplace=True)

# Function to recommend songs based on cosine similarity of a specific feature
def recommend_songs(feature_name, input_song):
    if feature_name in data.columns:  # Check if the feature exists in the dataset
        # Get the index of the song that matches the user input
        idx = data[data['title'].str.lower() == input_song.lower()].index
        if len(idx) == 0:
            print("Song not found.")
            return None

        idx = idx[0]  # Take the first index if multiple matches are found

        # Get the feature value of the selected song
        song_feature_value = data.at[idx, feature_name]

        # Find similar songs based on values
        selected_songs = data[(data[feature_name] >= song_feature_value - 10) & (data[feature_name] <= song_feature_value + 10)]
        return selected_songs.sample(min(10, len(selected_songs)))
    else:
        # For string-type features, proceed with cosine similarity calculation
        # Select the feature column
        feature_column = data[feature_name]

        # Transform the feature into TF-IDF vectors
        tfidf = TfidfVectorizer(stop_words='english')
        tfidf_matrix = tfidf.fit_transform(feature_column)

        # Compute the cosine similarity matrix
        cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

        # Get the index of the song that matches the user input
        idx = data[data['title'].str.lower() == input_song.lower()].index
        if len(idx) == 0:
            print("Song not found.")
            return None

        idx = idx[0]  # Take the first index if multiple matches are found

        # Get pairwise similarity scores of all songs with the user input
        sim_scores = list(enumerate(cosine_sim[idx]))

        # Sort the songs based on the similarity scores
        sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

        # Get the scores of the top 10 most similar songs
        sim_scores = sim_scores[1:11]

        # Get the song indices
        song_indices = [i[0] for i in sim_scores]

        # Return the top 10 most similar songs
        return data.iloc[song_indices]

# Get user input for the feature
feature_input = input("Enter a feature (title, artist, top genre, year, bpm, energy, danceability, dB, liveness, valence, duration, acousticness, speechiness, popularity): ")

# Check if the feature input is valid
if feature_input.lower() in features:
    if feature_input.lower() not in ['title', 'artist', 'top genre', 'year']:  # Exclude non-numeric features
        user_song_input = input("Enter a song name: ")
        recommendations = recommend_songs(feature_input.lower(), user_song_input)
    else:
        user_feature_input = input("Enter a single song name or a value: ")
        try:
            user_feature_input = int(user_feature_input)
        except ValueError:
            pass
        recommendations = recommend_songs(feature_input.lower(), user_feature_input)

    if recommendations is not None:
        print(f"\nTop 10 songs based on {feature_input.capitalize()} similarity:")
        print(recommendations[['title', 'artist']])
else:
    print("Invalid feature name. Please enter a valid feature.")